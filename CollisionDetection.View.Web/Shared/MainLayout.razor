@using Blazor.Extensions;
@using Blazor.Extensions.Canvas;
@using Blazor.Extensions.Canvas.Canvas2D;
@using CollisionDetection.Model
@using System.Configuration
@using CollisionDetection.Presentation
@using System.ComponentModel.DataAnnotations
@using System.Drawing
@using System.Timers

@inject IDefaultProvider defaults;
@inject IJSRuntime JSRuntime
@inherits LayoutComponentBase
@implements CollisionDetection.Presentation.ISimulationView

<div class="page">
    
    <header>
        <h1>On Building Collision Simulations</h1>
        <h2>A response to Reducible's introduction to computer graphics</h2>
        <h2>By Scott Kuehl-Shelby</h2>
    </header>
    
    <section id="simulation">
        <div id="simulationOptions">
            <div>
                <input type="button" class="fill" value="@Paused" @onclick="PauseOrContinue"/>
            </div>

            <div>
                <label for="shapeCount">Number Of Shapes</label>
                <input id="shapeCount" type="number" @bind-value="ShapeCount" min="0" max="@(defaults.GetDefault<int>(MonitoredProperty.MaximumShapeCount))"/>
            </div>

            <div>
                <label for="fps">Frames Per Second</label>
                <input id="fps" type="number" @bind-value="Fps" min="1" max="@(defaults.GetDefault<int>(MonitoredProperty.MaximumFrameRate))"/>
            </div>

            <div>
                <label for="showBoundingVolumes">Show Bounding Volumes</label>
                <input id="showBoundingVolumes" @bind-value="ShowBoundingVolumes" type="checkbox"/>
            </div>

            <div>
                <label for="showAverageRenderTime">Show Average Render Time</label>
                <input id="showAverageRenderTime" @bind-value="ShowAverageRenderTime" type="checkbox"/>
            </div>

            <div>
                <label for="sceneSplitMethod">BVH Split Method:</label>
                <select id="sceneSplitMethod" @bind="SplitMethod">
                    @foreach (var method in defaults.GetDefault<string[]>(MonitoredProperty.AvailableSplitMethods))
                    {
                        <option value="@method">@method</option>
                    }
                </select>
            </div>

            <div>
                <label for="collisionDetectionMethod">Collision Detection Method:</label>
                <select id="collisionDetectionMethod" @bind="CollisionHandler">
                    @foreach (var method in defaults.GetDefault<string[]>(MonitoredProperty.AvailableCollisionHandlers))
                    {
                        <option value="@method">@method</option>
                    }
                </select>
            </div>
        </div>
        
        <div id="simulationCanvas">
            <BECanvas @ref="CanvasReference"></BECanvas>
        </div>
    </section>

@code
    {
        private int fps;
        private int maxFps;
        private int shapeCount;
        private int maxShapeCount;
        private bool showBoundingVolumes;
        private bool showAverageRenderTime;
        private bool paused;
        private ISimulationPresenter presenter;
        private Timer timer;
        private string splitMethod;
        private string collisionHandler;

        protected Size CanvasSize { get; set; }

        protected string Paused => paused ? "Continue" : "Pause";

        private Canvas2DContext context;

        protected BECanvasComponent CanvasReference;
        


        protected int Fps
        {
            get => fps;
            set
            {
                if (0 <= value && value <= maxFps)
                {
                    fps = value;

                    if (timer != null)
                    {
                        timer.Interval = 1000.0 / value;
                    }
                    
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.FrameRate, fps));
                }
            }
        }

        protected int ShapeCount
        {
            get => shapeCount;
            set
            {
                if (0 <= value && value <= maxShapeCount)
                {
                    shapeCount = value;
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.ShapeCount, shapeCount));
                }
            } 
        }

        protected bool ShowBoundingVolumes
        {
            get => showBoundingVolumes;
            set
            {
                showBoundingVolumes = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.BoundingVolumeVisibility, value));
            }
        }

        protected bool ShowAverageRenderTime
        {
            get => showAverageRenderTime;
            set
            {
                showAverageRenderTime = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.AverageRenderTimeVisibility, value));
            }
        }

        protected string SplitMethod
        {
            get => splitMethod;
            set
            {
                splitMethod = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.SplitMethod, value));
            }
        }

        protected string CollisionHandler
        {
            get => collisionHandler;
            set
            {
                collisionHandler = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.CollisionHandler, value));
            }
        }

        public void PauseOrContinue()
        {
            paused = !paused;
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(MonitoredProperty.Paused, paused));
        }

        private async void RenderShapes(object sender, ElapsedEventArgs e)
        {
            await context.BeginBatchAsync();
            await context.ClearRectAsync(0, 0, CanvasSize.Width, CanvasSize.Height);
            presenter.DrawScene(new GraphicsWrapper(context));
            
            await context.EndBatchAsync();
        }

        #region Initialization

        protected override void OnInitialized()
        {
            base.OnInitialized();

            paused = defaults.GetDefault<bool>(MonitoredProperty.Paused);

            maxFps = defaults.GetDefault<int>(MonitoredProperty.MaximumFrameRate);
            Fps = defaults.GetDefault<int>(MonitoredProperty.FrameRate);

            maxShapeCount = defaults.GetDefault<int>(MonitoredProperty.MaximumShapeCount);
            shapeCount = defaults.GetDefault<int>(MonitoredProperty.ShapeCount);

            SplitMethod = defaults.GetDefault<string>(MonitoredProperty.SplitMethod);
            CollisionHandler = defaults.GetDefault<string>(MonitoredProperty.CollisionHandler);

            timer = new Timer(1000.0 / Fps);
            timer.Elapsed += RenderShapes;
            timer.Start();
        }

        protected override async Task OnAfterRenderAsync(bool firstRender)
        {
            if (firstRender)
            {
                CanvasSize = new Size(await JSRuntime.InvokeAsync<int>("getSimulationWidth"), await JSRuntime.InvokeAsync<int>("getSimulationHeight"));
                await JSRuntime.InvokeVoidAsync("setCanvasWidth", CanvasSize.Width);
                await JSRuntime.InvokeVoidAsync("setCanvasHeight", CanvasSize.Height);

                presenter = new Presenter(defaults, this);
            }

            context = await CanvasReference.CreateCanvas2DAsync();
        }

        #endregion

        #region ISimulationView Members

        public event EventHandler<PropertyChangedEventArgs> PropertyChanged;

        public object QueryProperty(MonitoredProperty monitoredProperty)
        {
            if (MonitoredProperty.WorldBounds == monitoredProperty)
            {
                return CanvasSize;
            }
            else
            {
                return null;
            }
        }

        public bool TryQueryProperty(MonitoredProperty monitoredProperty, out object value)
        {
            try
            {
                value = QueryProperty(monitoredProperty);
                return true;
            }
            catch (Exception)
            {
                value = null;
                return false;
            }
        }

        #endregion

    }
</div>
